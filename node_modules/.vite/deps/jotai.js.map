{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla.mjs", "../../jotai/esm/react.mjs"],
  "sourcesContent": ["let keyCount = 0;\r\nfunction atom(read, write) {\r\n  const key = `atom${++keyCount}`;\r\n  const config = {\r\n    toString: () => key\r\n  };\r\n  if (typeof read === \"function\") {\r\n    config.read = read;\r\n  } else {\r\n    config.init = read;\r\n    config.read = defaultRead;\r\n    config.write = defaultWrite;\r\n  }\r\n  if (write) {\r\n    config.write = write;\r\n  }\r\n  return config;\r\n}\r\nfunction defaultRead(get) {\r\n  return get(this);\r\n}\r\nfunction defaultWrite(get, set, arg) {\r\n  return set(\r\n    this,\r\n    typeof arg === \"function\" ? arg(get(this)) : arg\r\n  );\r\n}\r\n\r\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\r\nconst hasInitialValue = (atom) => \"init\" in atom;\r\nconst isActuallyWritableAtom = (atom) => !!atom.write;\r\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\r\nconst registerCancelPromise = (promise, cancel) => {\r\n  cancelPromiseMap.set(promise, cancel);\r\n  promise.catch(() => {\r\n  }).finally(() => cancelPromiseMap.delete(promise));\r\n};\r\nconst cancelPromise = (promise, next) => {\r\n  const cancel = cancelPromiseMap.get(promise);\r\n  if (cancel) {\r\n    cancelPromiseMap.delete(promise);\r\n    cancel(next);\r\n  }\r\n};\r\nconst resolvePromise = (promise, value) => {\r\n  promise.status = \"fulfilled\";\r\n  promise.value = value;\r\n};\r\nconst rejectPromise = (promise, e) => {\r\n  promise.status = \"rejected\";\r\n  promise.reason = e;\r\n};\r\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\r\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\r\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\r\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\r\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\r\nconst returnAtomValue = (atomState) => {\r\n  if (\"e\" in atomState) {\r\n    throw atomState.e;\r\n  }\r\n  return atomState.v;\r\n};\r\nconst createStore$1 = () => {\r\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\r\n  const mountedMap = /* @__PURE__ */ new WeakMap();\r\n  const pendingStack = [];\r\n  const pendingMap = /* @__PURE__ */ new WeakMap();\r\n  let devListenersRev2;\r\n  let mountedAtoms;\r\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n    devListenersRev2 = /* @__PURE__ */ new Set();\r\n    mountedAtoms = /* @__PURE__ */ new Set();\r\n  }\r\n  const getAtomState = (atom) => atomStateMap.get(atom);\r\n  const addPendingDependent = (atom, atomState) => {\r\n    atomState.d.forEach((_, a) => {\r\n      if (!pendingMap.has(a)) {\r\n        const aState = getAtomState(a);\r\n        pendingMap.set(a, [aState, /* @__PURE__ */ new Set()]);\r\n        if (aState) {\r\n          addPendingDependent(a, aState);\r\n        }\r\n      }\r\n      pendingMap.get(a)[1].add(atom);\r\n    });\r\n  };\r\n  const setAtomState = (atom, atomState) => {\r\n    var _a;\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      Object.freeze(atomState);\r\n    }\r\n    const prevAtomState = getAtomState(atom);\r\n    atomStateMap.set(atom, atomState);\r\n    (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);\r\n    if (!pendingMap.has(atom)) {\r\n      pendingMap.set(atom, [prevAtomState, /* @__PURE__ */ new Set()]);\r\n      addPendingDependent(atom, atomState);\r\n    }\r\n    if (hasPromiseAtomValue(prevAtomState)) {\r\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\r\n      if (prevAtomState.v !== next) {\r\n        cancelPromise(prevAtomState.v, next);\r\n      }\r\n    }\r\n  };\r\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\r\n    const dependencies = new Map(\r\n      keepPreviousDependencies ? nextAtomState.d : null\r\n    );\r\n    let changed = false;\r\n    nextDependencies.forEach((aState, a) => {\r\n      if (!aState && isSelfAtom(atom, a)) {\r\n        aState = nextAtomState;\r\n      }\r\n      if (aState) {\r\n        dependencies.set(a, aState);\r\n        if (nextAtomState.d.get(a) !== aState) {\r\n          changed = true;\r\n        }\r\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n        console.warn(\"[Bug] atom state not found\");\r\n      }\r\n    });\r\n    if (changed || nextAtomState.d.size !== dependencies.size) {\r\n      nextAtomState.d = dependencies;\r\n    }\r\n  };\r\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\r\n    const prevAtomState = getAtomState(atom);\r\n    const nextAtomState = {\r\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\r\n      v: value\r\n    };\r\n    if (nextDependencies) {\r\n      updateDependencies(\r\n        atom,\r\n        nextAtomState,\r\n        nextDependencies,\r\n        keepPreviousDependencies\r\n      );\r\n    }\r\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\r\n      return prevAtomState;\r\n    }\r\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\r\n      if (prevAtomState.d === nextAtomState.d) {\r\n        return prevAtomState;\r\n      } else {\r\n        nextAtomState.v = prevAtomState.v;\r\n      }\r\n    }\r\n    setAtomState(atom, nextAtomState);\r\n    return nextAtomState;\r\n  };\r\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\r\n    if (isPromiseLike(valueOrPromise)) {\r\n      let continuePromise;\r\n      const updatePromiseDependencies = () => {\r\n        const prevAtomState = getAtomState(atom);\r\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\r\n          return;\r\n        }\r\n        const nextAtomState = setAtomValue(\r\n          atom,\r\n          promise,\r\n          nextDependencies\r\n        );\r\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\r\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\r\n        }\r\n      };\r\n      const promise = new Promise((resolve, reject) => {\r\n        let settled = false;\r\n        valueOrPromise.then(\r\n          (v) => {\r\n            if (!settled) {\r\n              settled = true;\r\n              resolvePromise(promise, v);\r\n              resolve(v);\r\n              updatePromiseDependencies();\r\n            }\r\n          },\r\n          (e) => {\r\n            if (!settled) {\r\n              settled = true;\r\n              rejectPromise(promise, e);\r\n              reject(e);\r\n              updatePromiseDependencies();\r\n            }\r\n          }\r\n        );\r\n        continuePromise = (next) => {\r\n          if (!settled) {\r\n            settled = true;\r\n            next.then(\r\n              (v) => resolvePromise(promise, v),\r\n              (e) => rejectPromise(promise, e)\r\n            );\r\n            resolve(next);\r\n          }\r\n        };\r\n      });\r\n      promise.orig = valueOrPromise;\r\n      promise.status = \"pending\";\r\n      registerCancelPromise(promise, (next) => {\r\n        if (next) {\r\n          continuePromise(next);\r\n          abortPromise == null ? void 0 : abortPromise();\r\n        }\r\n      });\r\n      return setAtomValue(atom, promise, nextDependencies, true);\r\n    }\r\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\r\n  };\r\n  const setAtomError = (atom, error, nextDependencies) => {\r\n    const prevAtomState = getAtomState(atom);\r\n    const nextAtomState = {\r\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\r\n      e: error\r\n    };\r\n    if (nextDependencies) {\r\n      updateDependencies(atom, nextAtomState, nextDependencies);\r\n    }\r\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\r\n      return prevAtomState;\r\n    }\r\n    setAtomState(atom, nextAtomState);\r\n    return nextAtomState;\r\n  };\r\n  const readAtomState = (atom, force) => {\r\n    const atomState = getAtomState(atom);\r\n    if (!(force == null ? void 0 : force(atom)) && atomState) {\r\n      if (mountedMap.has(atom)) {\r\n        return atomState;\r\n      }\r\n      if (Array.from(atomState.d).every(([a, s]) => {\r\n        if (a === atom) {\r\n          return true;\r\n        }\r\n        const aState = readAtomState(a, force);\r\n        return aState === s || isEqualAtomValue(aState, s);\r\n      })) {\r\n        return atomState;\r\n      }\r\n    }\r\n    const nextDependencies = /* @__PURE__ */ new Map();\r\n    let isSync = true;\r\n    const getter = (a) => {\r\n      if (isSelfAtom(atom, a)) {\r\n        const aState2 = getAtomState(a);\r\n        if (aState2) {\r\n          nextDependencies.set(a, aState2);\r\n          return returnAtomValue(aState2);\r\n        }\r\n        if (hasInitialValue(a)) {\r\n          nextDependencies.set(a, void 0);\r\n          return a.init;\r\n        }\r\n        throw new Error(\"no atom init\");\r\n      }\r\n      const aState = readAtomState(a, force);\r\n      nextDependencies.set(a, aState);\r\n      return returnAtomValue(aState);\r\n    };\r\n    let controller;\r\n    let setSelf;\r\n    const options = {\r\n      get signal() {\r\n        if (!controller) {\r\n          controller = new AbortController();\r\n        }\r\n        return controller.signal;\r\n      },\r\n      get setSelf() {\r\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\r\n          console.warn(\"setSelf function cannot be used with read-only atom\");\r\n        }\r\n        if (!setSelf && isActuallyWritableAtom(atom)) {\r\n          setSelf = (...args) => {\r\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\r\n              console.warn(\"setSelf function cannot be called in sync\");\r\n            }\r\n            if (!isSync) {\r\n              return writeAtom(atom, ...args);\r\n            }\r\n          };\r\n        }\r\n        return setSelf;\r\n      }\r\n    };\r\n    try {\r\n      const valueOrPromise = atom.read(getter, options);\r\n      return setAtomValueOrPromise(\r\n        atom,\r\n        valueOrPromise,\r\n        nextDependencies,\r\n        () => controller == null ? void 0 : controller.abort()\r\n      );\r\n    } catch (error) {\r\n      return setAtomError(atom, error, nextDependencies);\r\n    } finally {\r\n      isSync = false;\r\n    }\r\n  };\r\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\r\n  const recomputeDependents = (atom) => {\r\n    const getDependents = (a) => {\r\n      var _a, _b;\r\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\r\n      (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent) => {\r\n        dependents.add(dependent);\r\n      });\r\n      return dependents;\r\n    };\r\n    const topsortedAtoms = new Array();\r\n    const markedAtoms = /* @__PURE__ */ new Set();\r\n    const visit = (n) => {\r\n      if (markedAtoms.has(n)) {\r\n        return;\r\n      }\r\n      markedAtoms.add(n);\r\n      for (const m of getDependents(n)) {\r\n        if (n !== m) {\r\n          visit(m);\r\n        }\r\n      }\r\n      topsortedAtoms.push(n);\r\n    };\r\n    visit(atom);\r\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\r\n    const isMarked = (a) => markedAtoms.has(a);\r\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\r\n      const a = topsortedAtoms[i];\r\n      const prevAtomState = getAtomState(a);\r\n      if (!prevAtomState) {\r\n        continue;\r\n      }\r\n      let hasChangedDeps = false;\r\n      for (const dep of prevAtomState.d.keys()) {\r\n        if (dep !== a && changedAtoms.has(dep)) {\r\n          hasChangedDeps = true;\r\n          break;\r\n        }\r\n      }\r\n      if (hasChangedDeps) {\r\n        const nextAtomState = readAtomState(a, isMarked);\r\n        addPendingDependent(a, nextAtomState);\r\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\r\n          changedAtoms.add(a);\r\n        }\r\n      }\r\n      markedAtoms.delete(a);\r\n    }\r\n  };\r\n  const writeAtomState = (atom, ...args) => {\r\n    const getter = (a) => returnAtomValue(readAtomState(a));\r\n    const setter = (a, ...args2) => {\r\n      const isSync = pendingStack.length > 0;\r\n      if (!isSync) {\r\n        pendingStack.push(/* @__PURE__ */ new Set([a]));\r\n      }\r\n      let r;\r\n      if (isSelfAtom(atom, a)) {\r\n        if (!hasInitialValue(a)) {\r\n          throw new Error(\"atom not writable\");\r\n        }\r\n        const prevAtomState = getAtomState(a);\r\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\r\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\r\n          recomputeDependents(a);\r\n        }\r\n      } else {\r\n        r = writeAtomState(a, ...args2);\r\n      }\r\n      if (!isSync) {\r\n        const flushed = flushPending(pendingStack.pop());\r\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n          devListenersRev2.forEach(\r\n            (l) => l({ type: \"async-write\", flushed })\r\n          );\r\n        }\r\n      }\r\n      return r;\r\n    };\r\n    const result = atom.write(getter, setter, ...args);\r\n    return result;\r\n  };\r\n  const writeAtom = (atom, ...args) => {\r\n    pendingStack.push(/* @__PURE__ */ new Set([atom]));\r\n    const result = writeAtomState(atom, ...args);\r\n    const flushed = flushPending(pendingStack.pop());\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      devListenersRev2.forEach((l) => l({ type: \"write\", flushed }));\r\n    }\r\n    return result;\r\n  };\r\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\r\n    var _a;\r\n    const existingMount = mountedMap.get(atom);\r\n    if (existingMount) {\r\n      if (initialDependent) {\r\n        existingMount.t.add(initialDependent);\r\n      }\r\n      return existingMount;\r\n    }\r\n    const queue = onMountQueue || [];\r\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\r\n      if (a !== atom) {\r\n        mountAtom(a, atom, queue);\r\n      }\r\n    });\r\n    readAtomState(atom);\r\n    const mounted = {\r\n      t: new Set(initialDependent && [initialDependent]),\r\n      l: /* @__PURE__ */ new Set()\r\n    };\r\n    mountedMap.set(atom, mounted);\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      mountedAtoms.add(atom);\r\n    }\r\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\r\n      const { onMount } = atom;\r\n      queue.push(() => {\r\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\r\n        if (onUnmount) {\r\n          mounted.u = onUnmount;\r\n        }\r\n      });\r\n    }\r\n    if (!onMountQueue) {\r\n      queue.forEach((f) => f());\r\n    }\r\n    return mounted;\r\n  };\r\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\r\n  const tryUnmountAtom = (atom, mounted) => {\r\n    if (!canUnmountAtom(atom, mounted)) {\r\n      return;\r\n    }\r\n    const onUnmount = mounted.u;\r\n    if (onUnmount) {\r\n      onUnmount();\r\n    }\r\n    mountedMap.delete(atom);\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      mountedAtoms.delete(atom);\r\n    }\r\n    const atomState = getAtomState(atom);\r\n    if (atomState) {\r\n      if (hasPromiseAtomValue(atomState)) {\r\n        cancelPromise(atomState.v);\r\n      }\r\n      atomState.d.forEach((_, a) => {\r\n        if (a !== atom) {\r\n          const mountedDep = mountedMap.get(a);\r\n          if (mountedDep) {\r\n            mountedDep.t.delete(atom);\r\n            tryUnmountAtom(a, mountedDep);\r\n          }\r\n        }\r\n      });\r\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\r\n    }\r\n  };\r\n  const mountDependencies = (atom, atomState, prevDependencies) => {\r\n    const depSet = new Set(atomState.d.keys());\r\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\r\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\r\n      if (depSet.has(a)) {\r\n        depSet.delete(a);\r\n        return;\r\n      }\r\n      maybeUnmountAtomSet.add(a);\r\n      const mounted = mountedMap.get(a);\r\n      if (mounted) {\r\n        mounted.t.delete(atom);\r\n      }\r\n    });\r\n    depSet.forEach((a) => {\r\n      mountAtom(a, atom);\r\n    });\r\n    maybeUnmountAtomSet.forEach((a) => {\r\n      const mounted = mountedMap.get(a);\r\n      if (mounted) {\r\n        tryUnmountAtom(a, mounted);\r\n      }\r\n    });\r\n  };\r\n  const flushPending = (pendingAtoms) => {\r\n    let flushed;\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      flushed = /* @__PURE__ */ new Set();\r\n    }\r\n    const pending = [];\r\n    const collectPending = (pendingAtom) => {\r\n      var _a;\r\n      if (!pendingMap.has(pendingAtom)) {\r\n        return;\r\n      }\r\n      const [prevAtomState, dependents] = pendingMap.get(pendingAtom);\r\n      pendingMap.delete(pendingAtom);\r\n      pending.push([pendingAtom, prevAtomState]);\r\n      dependents.forEach(collectPending);\r\n      (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a) => collectPending(a));\r\n    };\r\n    pendingAtoms.forEach(collectPending);\r\n    pending.forEach(([atom, prevAtomState]) => {\r\n      const atomState = getAtomState(atom);\r\n      if (!atomState) {\r\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n          console.warn(\"[Bug] no atom state to flush\");\r\n        }\r\n        return;\r\n      }\r\n      if (atomState !== prevAtomState) {\r\n        const mounted = mountedMap.get(atom);\r\n        if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\r\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\r\n        }\r\n        if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\r\n        // Maybe we could `mountDependencies` in `setAtomState`?\r\n        (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\r\n          mounted.l.forEach((listener) => listener());\r\n          if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n            flushed.add(atom);\r\n          }\r\n        }\r\n      }\r\n    });\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      return flushed;\r\n    }\r\n  };\r\n  const subscribeAtom = (atom, listener) => {\r\n    const mounted = mountAtom(atom);\r\n    const flushed = flushPending([atom]);\r\n    const listeners = mounted.l;\r\n    listeners.add(listener);\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      devListenersRev2.forEach(\r\n        (l) => l({ type: \"sub\", flushed })\r\n      );\r\n    }\r\n    return () => {\r\n      listeners.delete(listener);\r\n      tryUnmountAtom(atom, mounted);\r\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n        devListenersRev2.forEach((l) => l({ type: \"unsub\" }));\r\n      }\r\n    };\r\n  };\r\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n    return {\r\n      get: readAtom,\r\n      set: writeAtom,\r\n      sub: subscribeAtom,\r\n      // store dev methods (these are tentative and subject to change without notice)\r\n      dev_subscribe_store: (l) => {\r\n        devListenersRev2.add(l);\r\n        return () => {\r\n          devListenersRev2.delete(l);\r\n        };\r\n      },\r\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\r\n      dev_get_atom_state: (a) => atomStateMap.get(a),\r\n      dev_get_mounted: (a) => mountedMap.get(a),\r\n      dev_restore_atoms: (values) => {\r\n        pendingStack.push(/* @__PURE__ */ new Set());\r\n        for (const [atom, valueOrPromise] of values) {\r\n          if (hasInitialValue(atom)) {\r\n            setAtomValueOrPromise(atom, valueOrPromise);\r\n            recomputeDependents(atom);\r\n          }\r\n        }\r\n        const flushed = flushPending(pendingStack.pop());\r\n        devListenersRev2.forEach(\r\n          (l) => l({ type: \"restore\", flushed })\r\n        );\r\n      }\r\n    };\r\n  }\r\n  return {\r\n    get: readAtom,\r\n    set: writeAtom,\r\n    sub: subscribeAtom\r\n  };\r\n};\r\nlet defaultStore;\r\nconst getDefaultStore$1 = () => {\r\n  if (!defaultStore) {\r\n    defaultStore = createStore$1();\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\r\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\r\n        console.warn(\r\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return defaultStore;\r\n};\r\n\r\nSymbol(\r\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\"\r\n);\r\n\r\nconst createStore = createStore$1;\r\nconst getDefaultStore = getDefaultStore$1;\r\n\r\nexport { atom, createStore, getDefaultStore };\r\n", "'use client';\r\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\r\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\r\n\r\nconst StoreContext = createContext(\r\n  void 0\r\n);\r\nconst useStore = (options) => {\r\n  const store = useContext(StoreContext);\r\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\r\n};\r\nconst Provider = ({\r\n  children,\r\n  store\r\n}) => {\r\n  const storeRef = useRef();\r\n  if (!store && !storeRef.current) {\r\n    storeRef.current = createStore();\r\n  }\r\n  return createElement(\r\n    StoreContext.Provider,\r\n    {\r\n      value: store || storeRef.current\r\n    },\r\n    children\r\n  );\r\n};\r\n\r\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\r\nconst use = ReactExports.use || ((promise) => {\r\n  if (promise.status === \"pending\") {\r\n    throw promise;\r\n  } else if (promise.status === \"fulfilled\") {\r\n    return promise.value;\r\n  } else if (promise.status === \"rejected\") {\r\n    throw promise.reason;\r\n  } else {\r\n    promise.status = \"pending\";\r\n    promise.then(\r\n      (v) => {\r\n        promise.status = \"fulfilled\";\r\n        promise.value = v;\r\n      },\r\n      (e) => {\r\n        promise.status = \"rejected\";\r\n        promise.reason = e;\r\n      }\r\n    );\r\n    throw promise;\r\n  }\r\n});\r\nfunction useAtomValue(atom, options) {\r\n  const store = useStore(options);\r\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\r\n    (prev) => {\r\n      const nextValue = store.get(atom);\r\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\r\n        return prev;\r\n      }\r\n      return [nextValue, store, atom];\r\n    },\r\n    void 0,\r\n    () => [store.get(atom), store, atom]\r\n  );\r\n  let value = valueFromReducer;\r\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\r\n    rerender();\r\n    value = store.get(atom);\r\n  }\r\n  const delay = options == null ? void 0 : options.delay;\r\n  useEffect(() => {\r\n    const unsub = store.sub(atom, () => {\r\n      if (typeof delay === \"number\") {\r\n        setTimeout(rerender, delay);\r\n        return;\r\n      }\r\n      rerender();\r\n    });\r\n    rerender();\r\n    return unsub;\r\n  }, [store, atom, delay]);\r\n  useDebugValue(value);\r\n  return isPromiseLike(value) ? use(value) : value;\r\n}\r\n\r\nfunction useSetAtom(atom, options) {\r\n  const store = useStore(options);\r\n  const setAtom = useCallback(\r\n    (...args) => {\r\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\r\n        throw new Error(\"not writable atom\");\r\n      }\r\n      return store.set(atom, ...args);\r\n    },\r\n    [store, atom]\r\n  );\r\n  return setAtom;\r\n}\r\n\r\nfunction useAtom(atom, options) {\r\n  return [\r\n    useAtomValue(atom, options),\r\n    // We do wrong type assertion here, which results in throwing an error.\r\n    useSetAtom(atom, options)\r\n  ];\r\n}\r\n\r\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\r\n"],
  "mappings": ";;;;;;;;AAAA,IAAI,WAAW;AACf,SAAS,KAAK,MAAM,OAAO;AACzB,QAAM,MAAM,OAAO,EAAE,QAAQ;AAC7B,QAAM,SAAS;AAAA,IACb,UAAU,MAAM;AAAA,EAClB;AACA,MAAI,OAAO,SAAS,YAAY;AAC9B,WAAO,OAAO;AAAA,EAChB,OAAO;AACL,WAAO,OAAO;AACd,WAAO,OAAO;AACd,WAAO,QAAQ;AAAA,EACjB;AACA,MAAI,OAAO;AACT,WAAO,QAAQ;AAAA,EACjB;AACA,SAAO;AACT;AACA,SAAS,YAAY,KAAK;AACxB,SAAO,IAAI,IAAI;AACjB;AACA,SAAS,aAAa,KAAK,KAAK,KAAK;AACnC,SAAO;AAAA,IACL;AAAA,IACA,OAAO,QAAQ,aAAa,IAAI,IAAI,IAAI,CAAC,IAAI;AAAA,EAC/C;AACF;AAEA,IAAM,aAAa,CAACA,OAAM,MAAMA,MAAK,cAAcA,MAAK,YAAY,CAAC,IAAI,MAAMA;AAC/E,IAAM,kBAAkB,CAACA,UAAS,UAAUA;AAC5C,IAAM,yBAAyB,CAACA,UAAS,CAAC,CAACA,MAAK;AAChD,IAAM,mBAAmC,oBAAI,QAAQ;AACrD,IAAM,wBAAwB,CAAC,SAAS,WAAW;AACjD,mBAAiB,IAAI,SAAS,MAAM;AACpC,UAAQ,MAAM,MAAM;AAAA,EACpB,CAAC,EAAE,QAAQ,MAAM,iBAAiB,OAAO,OAAO,CAAC;AACnD;AACA,IAAM,gBAAgB,CAAC,SAAS,SAAS;AACvC,QAAM,SAAS,iBAAiB,IAAI,OAAO;AAC3C,MAAI,QAAQ;AACV,qBAAiB,OAAO,OAAO;AAC/B,WAAO,IAAI;AAAA,EACb;AACF;AACA,IAAM,iBAAiB,CAAC,SAAS,UAAU;AACzC,UAAQ,SAAS;AACjB,UAAQ,QAAQ;AAClB;AACA,IAAM,gBAAgB,CAAC,SAAS,MAAM;AACpC,UAAQ,SAAS;AACjB,UAAQ,SAAS;AACnB;AACA,IAAM,gBAAgB,CAAC,MAAM,QAAQ,KAAK,OAAO,SAAS,EAAE,UAAU;AACtE,IAAM,mBAAmB,CAAC,GAAG,MAAM,CAAC,CAAC,KAAK,OAAO,KAAK,OAAO,KAAK,OAAO,GAAG,EAAE,GAAG,EAAE,CAAC;AACpF,IAAM,mBAAmB,CAAC,GAAG,MAAM,CAAC,CAAC,KAAK,OAAO,KAAK,OAAO,KAAK,OAAO,GAAG,EAAE,GAAG,EAAE,CAAC;AACpF,IAAM,sBAAsB,CAAC,MAAM,CAAC,CAAC,KAAK,OAAO,KAAK,EAAE,aAAa;AACrE,IAAM,0BAA0B,CAAC,GAAG,MAAM,OAAO,KAAK,OAAO,KAAK,EAAE,EAAE,QAAQ,EAAE,EAAE,SAAS,EAAE,EAAE;AAC/F,IAAM,kBAAkB,CAAC,cAAc;AACrC,MAAI,OAAO,WAAW;AACpB,UAAM,UAAU;AAAA,EAClB;AACA,SAAO,UAAU;AACnB;AACA,IAAM,gBAAgB,MAAM;AAC1B,QAAM,eAA+B,oBAAI,QAAQ;AACjD,QAAM,aAA6B,oBAAI,QAAQ;AAC/C,QAAM,eAAe,CAAC;AACtB,QAAM,aAA6B,oBAAI,QAAQ;AAC/C,MAAI;AACJ,MAAI;AACJ,OAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,uBAAmC,oBAAI,IAAI;AAC3C,mBAA+B,oBAAI,IAAI;AAAA,EACzC;AACA,QAAM,eAAe,CAACA,UAAS,aAAa,IAAIA,KAAI;AACpD,QAAM,sBAAsB,CAACA,OAAM,cAAc;AAC/C,cAAU,EAAE,QAAQ,CAAC,GAAG,MAAM;AAC5B,UAAI,CAAC,WAAW,IAAI,CAAC,GAAG;AACtB,cAAM,SAAS,aAAa,CAAC;AAC7B,mBAAW,IAAI,GAAG,CAAC,QAAwB,oBAAI,IAAI,CAAC,CAAC;AACrD,YAAI,QAAQ;AACV,8BAAoB,GAAG,MAAM;AAAA,QAC/B;AAAA,MACF;AACA,iBAAW,IAAI,CAAC,EAAE,CAAC,EAAE,IAAIA,KAAI;AAAA,IAC/B,CAAC;AAAA,EACH;AACA,QAAM,eAAe,CAACA,OAAM,cAAc;AACxC,QAAI;AACJ,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,aAAO,OAAO,SAAS;AAAA,IACzB;AACA,UAAM,gBAAgB,aAAaA,KAAI;AACvC,iBAAa,IAAIA,OAAM,SAAS;AAChC,KAAC,KAAK,aAAa,aAAa,SAAS,CAAC,MAAM,OAAO,SAAS,GAAG,IAAIA,KAAI;AAC3E,QAAI,CAAC,WAAW,IAAIA,KAAI,GAAG;AACzB,iBAAW,IAAIA,OAAM,CAAC,eAA+B,oBAAI,IAAI,CAAC,CAAC;AAC/D,0BAAoBA,OAAM,SAAS;AAAA,IACrC;AACA,QAAI,oBAAoB,aAAa,GAAG;AACtC,YAAM,OAAO,OAAO,YAAY,UAAU,aAAa,UAAU,UAAU,IAAI,QAAQ,QAAQ,UAAU,CAAC,IAAI,QAAQ,OAAO,UAAU,CAAC;AACxI,UAAI,cAAc,MAAM,MAAM;AAC5B,sBAAc,cAAc,GAAG,IAAI;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AACA,QAAM,qBAAqB,CAACA,OAAM,eAAe,kBAAkB,6BAA6B;AAC9F,UAAM,eAAe,IAAI;AAAA,MACvB,2BAA2B,cAAc,IAAI;AAAA,IAC/C;AACA,QAAI,UAAU;AACd,qBAAiB,QAAQ,CAAC,QAAQ,MAAM;AACtC,UAAI,CAAC,UAAU,WAAWA,OAAM,CAAC,GAAG;AAClC,iBAAS;AAAA,MACX;AACA,UAAI,QAAQ;AACV,qBAAa,IAAI,GAAG,MAAM;AAC1B,YAAI,cAAc,EAAE,IAAI,CAAC,MAAM,QAAQ;AACrC,oBAAU;AAAA,QACZ;AAAA,MACF,YAAY,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AAC7E,gBAAQ,KAAK,4BAA4B;AAAA,MAC3C;AAAA,IACF,CAAC;AACD,QAAI,WAAW,cAAc,EAAE,SAAS,aAAa,MAAM;AACzD,oBAAc,IAAI;AAAA,IACpB;AAAA,EACF;AACA,QAAM,eAAe,CAACA,OAAM,OAAO,kBAAkB,6BAA6B;AAChF,UAAM,gBAAgB,aAAaA,KAAI;AACvC,UAAM,gBAAgB;AAAA,MACpB,IAAI,iBAAiB,OAAO,SAAS,cAAc,MAAsB,oBAAI,IAAI;AAAA,MACjF,GAAG;AAAA,IACL;AACA,QAAI,kBAAkB;AACpB;AAAA,QACEA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,QAAI,iBAAiB,eAAe,aAAa,KAAK,cAAc,MAAM,cAAc,GAAG;AACzF,aAAO;AAAA,IACT;AACA,QAAI,oBAAoB,aAAa,KAAK,oBAAoB,aAAa,KAAK,wBAAwB,eAAe,aAAa,GAAG;AACrI,UAAI,cAAc,MAAM,cAAc,GAAG;AACvC,eAAO;AAAA,MACT,OAAO;AACL,sBAAc,IAAI,cAAc;AAAA,MAClC;AAAA,IACF;AACA,iBAAaA,OAAM,aAAa;AAChC,WAAO;AAAA,EACT;AACA,QAAM,wBAAwB,CAACA,OAAM,gBAAgB,kBAAkB,iBAAiB;AACtF,QAAI,cAAc,cAAc,GAAG;AACjC,UAAI;AACJ,YAAM,4BAA4B,MAAM;AACtC,cAAM,gBAAgB,aAAaA,KAAI;AACvC,YAAI,CAAC,oBAAoB,aAAa,KAAK,cAAc,MAAM,SAAS;AACtE;AAAA,QACF;AACA,cAAM,gBAAgB;AAAA,UACpBA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AACA,YAAI,WAAW,IAAIA,KAAI,KAAK,cAAc,MAAM,cAAc,GAAG;AAC/D,4BAAkBA,OAAM,eAAe,cAAc,CAAC;AAAA,QACxD;AAAA,MACF;AACA,YAAM,UAAU,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC/C,YAAI,UAAU;AACd,uBAAe;AAAA,UACb,CAAC,MAAM;AACL,gBAAI,CAAC,SAAS;AACZ,wBAAU;AACV,6BAAe,SAAS,CAAC;AACzB,sBAAQ,CAAC;AACT,wCAA0B;AAAA,YAC5B;AAAA,UACF;AAAA,UACA,CAAC,MAAM;AACL,gBAAI,CAAC,SAAS;AACZ,wBAAU;AACV,4BAAc,SAAS,CAAC;AACxB,qBAAO,CAAC;AACR,wCAA0B;AAAA,YAC5B;AAAA,UACF;AAAA,QACF;AACA,0BAAkB,CAAC,SAAS;AAC1B,cAAI,CAAC,SAAS;AACZ,sBAAU;AACV,iBAAK;AAAA,cACH,CAAC,MAAM,eAAe,SAAS,CAAC;AAAA,cAChC,CAAC,MAAM,cAAc,SAAS,CAAC;AAAA,YACjC;AACA,oBAAQ,IAAI;AAAA,UACd;AAAA,QACF;AAAA,MACF,CAAC;AACD,cAAQ,OAAO;AACf,cAAQ,SAAS;AACjB,4BAAsB,SAAS,CAAC,SAAS;AACvC,YAAI,MAAM;AACR,0BAAgB,IAAI;AACpB,0BAAgB,OAAO,SAAS,aAAa;AAAA,QAC/C;AAAA,MACF,CAAC;AACD,aAAO,aAAaA,OAAM,SAAS,kBAAkB,IAAI;AAAA,IAC3D;AACA,WAAO,aAAaA,OAAM,gBAAgB,gBAAgB;AAAA,EAC5D;AACA,QAAM,eAAe,CAACA,OAAM,OAAO,qBAAqB;AACtD,UAAM,gBAAgB,aAAaA,KAAI;AACvC,UAAM,gBAAgB;AAAA,MACpB,IAAI,iBAAiB,OAAO,SAAS,cAAc,MAAsB,oBAAI,IAAI;AAAA,MACjF,GAAG;AAAA,IACL;AACA,QAAI,kBAAkB;AACpB,yBAAmBA,OAAM,eAAe,gBAAgB;AAAA,IAC1D;AACA,QAAI,iBAAiB,eAAe,aAAa,KAAK,cAAc,MAAM,cAAc,GAAG;AACzF,aAAO;AAAA,IACT;AACA,iBAAaA,OAAM,aAAa;AAChC,WAAO;AAAA,EACT;AACA,QAAM,gBAAgB,CAACA,OAAM,UAAU;AACrC,UAAM,YAAY,aAAaA,KAAI;AACnC,QAAI,EAAE,SAAS,OAAO,SAAS,MAAMA,KAAI,MAAM,WAAW;AACxD,UAAI,WAAW,IAAIA,KAAI,GAAG;AACxB,eAAO;AAAA,MACT;AACA,UAAI,MAAM,KAAK,UAAU,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,CAAC,MAAM;AAC5C,YAAI,MAAMA,OAAM;AACd,iBAAO;AAAA,QACT;AACA,cAAM,SAAS,cAAc,GAAG,KAAK;AACrC,eAAO,WAAW,KAAK,iBAAiB,QAAQ,CAAC;AAAA,MACnD,CAAC,GAAG;AACF,eAAO;AAAA,MACT;AAAA,IACF;AACA,UAAM,mBAAmC,oBAAI,IAAI;AACjD,QAAI,SAAS;AACb,UAAM,SAAS,CAAC,MAAM;AACpB,UAAI,WAAWA,OAAM,CAAC,GAAG;AACvB,cAAM,UAAU,aAAa,CAAC;AAC9B,YAAI,SAAS;AACX,2BAAiB,IAAI,GAAG,OAAO;AAC/B,iBAAO,gBAAgB,OAAO;AAAA,QAChC;AACA,YAAI,gBAAgB,CAAC,GAAG;AACtB,2BAAiB,IAAI,GAAG,MAAM;AAC9B,iBAAO,EAAE;AAAA,QACX;AACA,cAAM,IAAI,MAAM,cAAc;AAAA,MAChC;AACA,YAAM,SAAS,cAAc,GAAG,KAAK;AACrC,uBAAiB,IAAI,GAAG,MAAM;AAC9B,aAAO,gBAAgB,MAAM;AAAA,IAC/B;AACA,QAAI;AACJ,QAAI;AACJ,UAAM,UAAU;AAAA,MACd,IAAI,SAAS;AACX,YAAI,CAAC,YAAY;AACf,uBAAa,IAAI,gBAAgB;AAAA,QACnC;AACA,eAAO,WAAW;AAAA,MACpB;AAAA,MACA,IAAI,UAAU;AACZ,aAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,CAAC,uBAAuBA,KAAI,GAAG;AACvG,kBAAQ,KAAK,qDAAqD;AAAA,QACpE;AACA,YAAI,CAAC,WAAW,uBAAuBA,KAAI,GAAG;AAC5C,oBAAU,IAAI,SAAS;AACrB,iBAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,QAAQ;AAChF,sBAAQ,KAAK,2CAA2C;AAAA,YAC1D;AACA,gBAAI,CAAC,QAAQ;AACX,qBAAO,UAAUA,OAAM,GAAG,IAAI;AAAA,YAChC;AAAA,UACF;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAAA,IACF;AACA,QAAI;AACF,YAAM,iBAAiBA,MAAK,KAAK,QAAQ,OAAO;AAChD,aAAO;AAAA,QACLA;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM,cAAc,OAAO,SAAS,WAAW,MAAM;AAAA,MACvD;AAAA,IACF,SAAS,OAAO;AACd,aAAO,aAAaA,OAAM,OAAO,gBAAgB;AAAA,IACnD,UAAE;AACA,eAAS;AAAA,IACX;AAAA,EACF;AACA,QAAM,WAAW,CAACA,UAAS,gBAAgB,cAAcA,KAAI,CAAC;AAC9D,QAAM,sBAAsB,CAACA,UAAS;AACpC,UAAM,gBAAgB,CAAC,MAAM;AAC3B,UAAI,IAAI;AACR,YAAM,aAAa,IAAI,KAAK,KAAK,WAAW,IAAI,CAAC,MAAM,OAAO,SAAS,GAAG,CAAC;AAC3E,OAAC,KAAK,WAAW,IAAI,CAAC,MAAM,OAAO,SAAS,GAAG,CAAC,EAAE,QAAQ,CAAC,cAAc;AACvE,mBAAW,IAAI,SAAS;AAAA,MAC1B,CAAC;AACD,aAAO;AAAA,IACT;AACA,UAAM,iBAAiB,IAAI,MAAM;AACjC,UAAM,cAA8B,oBAAI,IAAI;AAC5C,UAAM,QAAQ,CAAC,MAAM;AACnB,UAAI,YAAY,IAAI,CAAC,GAAG;AACtB;AAAA,MACF;AACA,kBAAY,IAAI,CAAC;AACjB,iBAAW,KAAK,cAAc,CAAC,GAAG;AAChC,YAAI,MAAM,GAAG;AACX,gBAAM,CAAC;AAAA,QACT;AAAA,MACF;AACA,qBAAe,KAAK,CAAC;AAAA,IACvB;AACA,UAAMA,KAAI;AACV,UAAM,eAA+B,oBAAI,IAAI,CAACA,KAAI,CAAC;AACnD,UAAM,WAAW,CAAC,MAAM,YAAY,IAAI,CAAC;AACzC,aAAS,IAAI,eAAe,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACnD,YAAM,IAAI,eAAe,CAAC;AAC1B,YAAM,gBAAgB,aAAa,CAAC;AACpC,UAAI,CAAC,eAAe;AAClB;AAAA,MACF;AACA,UAAI,iBAAiB;AACrB,iBAAW,OAAO,cAAc,EAAE,KAAK,GAAG;AACxC,YAAI,QAAQ,KAAK,aAAa,IAAI,GAAG,GAAG;AACtC,2BAAiB;AACjB;AAAA,QACF;AAAA,MACF;AACA,UAAI,gBAAgB;AAClB,cAAM,gBAAgB,cAAc,GAAG,QAAQ;AAC/C,4BAAoB,GAAG,aAAa;AACpC,YAAI,CAAC,iBAAiB,eAAe,aAAa,GAAG;AACnD,uBAAa,IAAI,CAAC;AAAA,QACpB;AAAA,MACF;AACA,kBAAY,OAAO,CAAC;AAAA,IACtB;AAAA,EACF;AACA,QAAM,iBAAiB,CAACA,UAAS,SAAS;AACxC,UAAM,SAAS,CAAC,MAAM,gBAAgB,cAAc,CAAC,CAAC;AACtD,UAAM,SAAS,CAAC,MAAM,UAAU;AAC9B,YAAM,SAAS,aAAa,SAAS;AACrC,UAAI,CAAC,QAAQ;AACX,qBAAa,KAAqB,oBAAI,IAAI,CAAC,CAAC,CAAC,CAAC;AAAA,MAChD;AACA,UAAI;AACJ,UAAI,WAAWA,OAAM,CAAC,GAAG;AACvB,YAAI,CAAC,gBAAgB,CAAC,GAAG;AACvB,gBAAM,IAAI,MAAM,mBAAmB;AAAA,QACrC;AACA,cAAM,gBAAgB,aAAa,CAAC;AACpC,cAAM,gBAAgB,sBAAsB,GAAG,MAAM,CAAC,CAAC;AACvD,YAAI,CAAC,iBAAiB,eAAe,aAAa,GAAG;AACnD,8BAAoB,CAAC;AAAA,QACvB;AAAA,MACF,OAAO;AACL,YAAI,eAAe,GAAG,GAAG,KAAK;AAAA,MAChC;AACA,UAAI,CAAC,QAAQ;AACX,cAAM,UAAU,aAAa,aAAa,IAAI,CAAC;AAC/C,aAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,2BAAiB;AAAA,YACf,CAAC,MAAM,EAAE,EAAE,MAAM,eAAe,QAAQ,CAAC;AAAA,UAC3C;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,UAAM,SAASA,MAAK,MAAM,QAAQ,QAAQ,GAAG,IAAI;AACjD,WAAO;AAAA,EACT;AACA,QAAM,YAAY,CAACA,UAAS,SAAS;AACnC,iBAAa,KAAqB,oBAAI,IAAI,CAACA,KAAI,CAAC,CAAC;AACjD,UAAM,SAAS,eAAeA,OAAM,GAAG,IAAI;AAC3C,UAAM,UAAU,aAAa,aAAa,IAAI,CAAC;AAC/C,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,uBAAiB,QAAQ,CAAC,MAAM,EAAE,EAAE,MAAM,SAAS,QAAQ,CAAC,CAAC;AAAA,IAC/D;AACA,WAAO;AAAA,EACT;AACA,QAAM,YAAY,CAACA,OAAM,kBAAkB,iBAAiB;AAC1D,QAAI;AACJ,UAAM,gBAAgB,WAAW,IAAIA,KAAI;AACzC,QAAI,eAAe;AACjB,UAAI,kBAAkB;AACpB,sBAAc,EAAE,IAAI,gBAAgB;AAAA,MACtC;AACA,aAAO;AAAA,IACT;AACA,UAAM,QAAQ,gBAAgB,CAAC;AAC/B,KAAC,KAAK,aAAaA,KAAI,MAAM,OAAO,SAAS,GAAG,EAAE,QAAQ,CAAC,GAAG,MAAM;AAClE,UAAI,MAAMA,OAAM;AACd,kBAAU,GAAGA,OAAM,KAAK;AAAA,MAC1B;AAAA,IACF,CAAC;AACD,kBAAcA,KAAI;AAClB,UAAM,UAAU;AAAA,MACd,GAAG,IAAI,IAAI,oBAAoB,CAAC,gBAAgB,CAAC;AAAA,MACjD,GAAmB,oBAAI,IAAI;AAAA,IAC7B;AACA,eAAW,IAAIA,OAAM,OAAO;AAC5B,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,mBAAa,IAAIA,KAAI;AAAA,IACvB;AACA,QAAI,uBAAuBA,KAAI,KAAKA,MAAK,SAAS;AAChD,YAAM,EAAE,QAAQ,IAAIA;AACpB,YAAM,KAAK,MAAM;AACf,cAAM,YAAY,QAAQ,IAAI,SAAS,UAAUA,OAAM,GAAG,IAAI,CAAC;AAC/D,YAAI,WAAW;AACb,kBAAQ,IAAI;AAAA,QACd;AAAA,MACF,CAAC;AAAA,IACH;AACA,QAAI,CAAC,cAAc;AACjB,YAAM,QAAQ,CAAC,MAAM,EAAE,CAAC;AAAA,IAC1B;AACA,WAAO;AAAA,EACT;AACA,QAAM,iBAAiB,CAACA,OAAM,YAAY,CAAC,QAAQ,EAAE,SAAS,CAAC,QAAQ,EAAE,QAAQ,QAAQ,EAAE,SAAS,KAAK,QAAQ,EAAE,IAAIA,KAAI;AAC3H,QAAM,iBAAiB,CAACA,OAAM,YAAY;AACxC,QAAI,CAAC,eAAeA,OAAM,OAAO,GAAG;AAClC;AAAA,IACF;AACA,UAAM,YAAY,QAAQ;AAC1B,QAAI,WAAW;AACb,gBAAU;AAAA,IACZ;AACA,eAAW,OAAOA,KAAI;AACtB,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,mBAAa,OAAOA,KAAI;AAAA,IAC1B;AACA,UAAM,YAAY,aAAaA,KAAI;AACnC,QAAI,WAAW;AACb,UAAI,oBAAoB,SAAS,GAAG;AAClC,sBAAc,UAAU,CAAC;AAAA,MAC3B;AACA,gBAAU,EAAE,QAAQ,CAAC,GAAG,MAAM;AAC5B,YAAI,MAAMA,OAAM;AACd,gBAAM,aAAa,WAAW,IAAI,CAAC;AACnC,cAAI,YAAY;AACd,uBAAW,EAAE,OAAOA,KAAI;AACxB,2BAAe,GAAG,UAAU;AAAA,UAC9B;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,YAAY,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AAC7E,cAAQ,KAAK,8CAA8CA,KAAI;AAAA,IACjE;AAAA,EACF;AACA,QAAM,oBAAoB,CAACA,OAAM,WAAW,qBAAqB;AAC/D,UAAM,SAAS,IAAI,IAAI,UAAU,EAAE,KAAK,CAAC;AACzC,UAAM,sBAAsC,oBAAI,IAAI;AACpD,wBAAoB,OAAO,SAAS,iBAAiB,QAAQ,CAAC,GAAG,MAAM;AACrE,UAAI,OAAO,IAAI,CAAC,GAAG;AACjB,eAAO,OAAO,CAAC;AACf;AAAA,MACF;AACA,0BAAoB,IAAI,CAAC;AACzB,YAAM,UAAU,WAAW,IAAI,CAAC;AAChC,UAAI,SAAS;AACX,gBAAQ,EAAE,OAAOA,KAAI;AAAA,MACvB;AAAA,IACF,CAAC;AACD,WAAO,QAAQ,CAAC,MAAM;AACpB,gBAAU,GAAGA,KAAI;AAAA,IACnB,CAAC;AACD,wBAAoB,QAAQ,CAAC,MAAM;AACjC,YAAM,UAAU,WAAW,IAAI,CAAC;AAChC,UAAI,SAAS;AACX,uBAAe,GAAG,OAAO;AAAA,MAC3B;AAAA,IACF,CAAC;AAAA,EACH;AACA,QAAM,eAAe,CAAC,iBAAiB;AACrC,QAAI;AACJ,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,gBAA0B,oBAAI,IAAI;AAAA,IACpC;AACA,UAAM,UAAU,CAAC;AACjB,UAAM,iBAAiB,CAAC,gBAAgB;AACtC,UAAI;AACJ,UAAI,CAAC,WAAW,IAAI,WAAW,GAAG;AAChC;AAAA,MACF;AACA,YAAM,CAAC,eAAe,UAAU,IAAI,WAAW,IAAI,WAAW;AAC9D,iBAAW,OAAO,WAAW;AAC7B,cAAQ,KAAK,CAAC,aAAa,aAAa,CAAC;AACzC,iBAAW,QAAQ,cAAc;AACjC,OAAC,KAAK,aAAa,WAAW,MAAM,OAAO,SAAS,GAAG,EAAE,QAAQ,CAAC,GAAG,MAAM,eAAe,CAAC,CAAC;AAAA,IAC9F;AACA,iBAAa,QAAQ,cAAc;AACnC,YAAQ,QAAQ,CAAC,CAACA,OAAM,aAAa,MAAM;AACzC,YAAM,YAAY,aAAaA,KAAI;AACnC,UAAI,CAAC,WAAW;AACd,aAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,kBAAQ,KAAK,8BAA8B;AAAA,QAC7C;AACA;AAAA,MACF;AACA,UAAI,cAAc,eAAe;AAC/B,cAAM,UAAU,WAAW,IAAIA,KAAI;AACnC,YAAI,WAAW,UAAU,OAAO,iBAAiB,OAAO,SAAS,cAAc,IAAI;AACjF,4BAAkBA,OAAM,WAAW,iBAAiB,OAAO,SAAS,cAAc,CAAC;AAAA,QACrF;AACA,YAAI,WAAW;AAAA;AAAA,SAEd,CAAC,oBAAoB,aAAa,MAAM,iBAAiB,eAAe,SAAS,KAAK,iBAAiB,eAAe,SAAS,KAAK;AACnI,kBAAQ,EAAE,QAAQ,CAAC,aAAa,SAAS,CAAC;AAC1C,eAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,oBAAQ,IAAIA,KAAI;AAAA,UAClB;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AACD,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,aAAO;AAAA,IACT;AAAA,EACF;AACA,QAAM,gBAAgB,CAACA,OAAM,aAAa;AACxC,UAAM,UAAU,UAAUA,KAAI;AAC9B,UAAM,UAAU,aAAa,CAACA,KAAI,CAAC;AACnC,UAAM,YAAY,QAAQ;AAC1B,cAAU,IAAI,QAAQ;AACtB,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,uBAAiB;AAAA,QACf,CAAC,MAAM,EAAE,EAAE,MAAM,OAAO,QAAQ,CAAC;AAAA,MACnC;AAAA,IACF;AACA,WAAO,MAAM;AACX,gBAAU,OAAO,QAAQ;AACzB,qBAAeA,OAAM,OAAO;AAC5B,WAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,yBAAiB,QAAQ,CAAC,MAAM,EAAE,EAAE,MAAM,QAAQ,CAAC,CAAC;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AACA,OAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,WAAO;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA;AAAA,MAEL,qBAAqB,CAAC,MAAM;AAC1B,yBAAiB,IAAI,CAAC;AACtB,eAAO,MAAM;AACX,2BAAiB,OAAO,CAAC;AAAA,QAC3B;AAAA,MACF;AAAA,MACA,uBAAuB,MAAM,aAAa,OAAO;AAAA,MACjD,oBAAoB,CAAC,MAAM,aAAa,IAAI,CAAC;AAAA,MAC7C,iBAAiB,CAAC,MAAM,WAAW,IAAI,CAAC;AAAA,MACxC,mBAAmB,CAAC,WAAW;AAC7B,qBAAa,KAAqB,oBAAI,IAAI,CAAC;AAC3C,mBAAW,CAACA,OAAM,cAAc,KAAK,QAAQ;AAC3C,cAAI,gBAAgBA,KAAI,GAAG;AACzB,kCAAsBA,OAAM,cAAc;AAC1C,gCAAoBA,KAAI;AAAA,UAC1B;AAAA,QACF;AACA,cAAM,UAAU,aAAa,aAAa,IAAI,CAAC;AAC/C,yBAAiB;AAAA,UACf,CAAC,MAAM,EAAE,EAAE,MAAM,WAAW,QAAQ,CAAC;AAAA,QACvC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,EACP;AACF;AACA,IAAI;AACJ,IAAM,oBAAoB,MAAM;AAC9B,MAAI,CAAC,cAAc;AACjB,mBAAe,cAAc;AAC7B,SAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,cAAc;AACtE,iBAAW,4BAA4B,WAAW,0BAA0B;AAC5E,UAAI,WAAW,4BAA4B,cAAc;AACvD,gBAAQ;AAAA,UACN;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA;AAAA,GACG,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,eAAe,qBAAqB;AAC5F;AAEA,IAAM,cAAc;AACpB,IAAM,kBAAkB;;;ACjmBxB,mBAAkI;AAGlI,IAAM,mBAAe;AAAA,EACnB;AACF;AACA,IAAM,WAAW,CAAC,YAAY;AAC5B,QAAM,YAAQ,yBAAW,YAAY;AACrC,UAAQ,WAAW,OAAO,SAAS,QAAQ,UAAU,SAAS,gBAAgB;AAChF;AACA,IAAM,WAAW,CAAC;AAAA,EAChB;AAAA,EACA;AACF,MAAM;AACJ,QAAM,eAAW,qBAAO;AACxB,MAAI,CAAC,SAAS,CAAC,SAAS,SAAS;AAC/B,aAAS,UAAU,YAAY;AAAA,EACjC;AACA,aAAO;AAAA,IACL,aAAa;AAAA,IACb;AAAA,MACE,OAAO,SAAS,SAAS;AAAA,IAC3B;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAMC,iBAAgB,CAAC,MAAM,QAAQ,KAAK,OAAO,SAAS,EAAE,UAAU;AACtE,IAAM,MAAM,aAAAC,QAAa,QAAQ,CAAC,YAAY;AAC5C,MAAI,QAAQ,WAAW,WAAW;AAChC,UAAM;AAAA,EACR,WAAW,QAAQ,WAAW,aAAa;AACzC,WAAO,QAAQ;AAAA,EACjB,WAAW,QAAQ,WAAW,YAAY;AACxC,UAAM,QAAQ;AAAA,EAChB,OAAO;AACL,YAAQ,SAAS;AACjB,YAAQ;AAAA,MACN,CAAC,MAAM;AACL,gBAAQ,SAAS;AACjB,gBAAQ,QAAQ;AAAA,MAClB;AAAA,MACA,CAAC,MAAM;AACL,gBAAQ,SAAS;AACjB,gBAAQ,SAAS;AAAA,MACnB;AAAA,IACF;AACA,UAAM;AAAA,EACR;AACF;AACA,SAAS,aAAaC,OAAM,SAAS;AACnC,QAAM,QAAQ,SAAS,OAAO;AAC9B,QAAM,CAAC,CAAC,kBAAkB,kBAAkB,eAAe,GAAG,QAAQ,QAAI;AAAA,IACxE,CAAC,SAAS;AACR,YAAM,YAAY,MAAM,IAAIA,KAAI;AAChC,UAAI,OAAO,GAAG,KAAK,CAAC,GAAG,SAAS,KAAK,KAAK,CAAC,MAAM,SAAS,KAAK,CAAC,MAAMA,OAAM;AAC1E,eAAO;AAAA,MACT;AACA,aAAO,CAAC,WAAW,OAAOA,KAAI;AAAA,IAChC;AAAA,IACA;AAAA,IACA,MAAM,CAAC,MAAM,IAAIA,KAAI,GAAG,OAAOA,KAAI;AAAA,EACrC;AACA,MAAI,QAAQ;AACZ,MAAI,qBAAqB,SAAS,oBAAoBA,OAAM;AAC1D,aAAS;AACT,YAAQ,MAAM,IAAIA,KAAI;AAAA,EACxB;AACA,QAAM,QAAQ,WAAW,OAAO,SAAS,QAAQ;AACjD,8BAAU,MAAM;AACd,UAAM,QAAQ,MAAM,IAAIA,OAAM,MAAM;AAClC,UAAI,OAAO,UAAU,UAAU;AAC7B,mBAAW,UAAU,KAAK;AAC1B;AAAA,MACF;AACA,eAAS;AAAA,IACX,CAAC;AACD,aAAS;AACT,WAAO;AAAA,EACT,GAAG,CAAC,OAAOA,OAAM,KAAK,CAAC;AACvB,kCAAc,KAAK;AACnB,SAAOF,eAAc,KAAK,IAAI,IAAI,KAAK,IAAI;AAC7C;AAEA,SAAS,WAAWE,OAAM,SAAS;AACjC,QAAM,QAAQ,SAAS,OAAO;AAC9B,QAAM,cAAU;AAAA,IACd,IAAI,SAAS;AACX,WAAK,YAAY,MAAM,YAAY,IAAI,OAAO,YAAY,gBAAgB,EAAE,WAAWA,QAAO;AAC5F,cAAM,IAAI,MAAM,mBAAmB;AAAA,MACrC;AACA,aAAO,MAAM,IAAIA,OAAM,GAAG,IAAI;AAAA,IAChC;AAAA,IACA,CAAC,OAAOA,KAAI;AAAA,EACd;AACA,SAAO;AACT;AAEA,SAAS,QAAQA,OAAM,SAAS;AAC9B,SAAO;AAAA,IACL,aAAaA,OAAM,OAAO;AAAA;AAAA,IAE1B,WAAWA,OAAM,OAAO;AAAA,EAC1B;AACF;",
  "names": ["atom", "isPromiseLike", "ReactExports", "atom"]
}
